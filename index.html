<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Hello World</title>
    <style>
      * {
        padding: 0;
        margin: 0;
      }
      body {
        overflow: hidden;
      }
      /* body::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: repeating-linear-gradient(
          0deg,
          rgba(255, 255, 255, 0.05),
          rgba(112, 255, 233, 0.05) 5px,
          transparent 1px,
          transparent 2px
        );
        z-index: 100000;
        pointer-events: none;
      } */
      #canvas__wrapper {
        position: absolute;
        /* top: 50px; */
        /* transition: transform 250ms ease-out; */
      }
    </style>
  </head>
  <script src="stats/stats.min.js"></script>

  <script src="pixi/pixi.min.js"></script>
  <body>
    <div id="canvas__wrapper"></div>
    <script type="text/javascript">
      var stats = new Stats();
      stats.showPanel(0, 1, 2); // 0: fps, 1: ms, 2: mb, 3+: custom

      document.body.appendChild(stats.dom);
      let type = "WebGL";
      if (!PIXI.utils.isWebGLSupported()) {
        type = "canvas";
      }

      PIXI.utils.sayHello(type);

      function getRandomWholeNumber(min, max) {
        return Math.floor(Math.random() * max) + min;
      }

      function distanceAndAngleBetweenTwoPoints(x1, y1, x2, y2) {
        const x = x2 - x1;
        const y = y2 - y1;

        return {
          distance: Math.sqrt(x * x + y * y),
          angle: (Math.atan2(y, x) * 180) / Math.PI
        };
      }

      function Vector(magnitude, angle) {
        var angleRadians = (angle * Math.PI) / 180;

        this.magnitudeX = magnitude * Math.cos(angleRadians);
        this.magnitudeY = magnitude * Math.sin(angleRadians);
      }

      function generateFleet() {
        const fleet = new Array(1000).fill(undefined).map((value, index) => {
          const origin = {
            x: getRandomWholeNumber(0, width),
            y: getRandomWholeNumber(0, height)
          };
          let destination = {
            x: getRandomWholeNumber(0, width),
            y: getRandomWholeNumber(0, height)
          };
          return {
            name: `SHIP-${index}`,
            origin,
            destination,
            direction: origin.x > destination.x ? "west" : "east",
            directionY: origin.y > destination.y ? "north" : "south",
            coordinates: origin,
            // id: uuid(),
            status: "STD",
            velocity: 1000,
            radius: {
              base: 3,
              hover: 10,
              selected: 6
            },
            maxVelocity: 10,
            prepTime: 10,
            scanning: {
              active: false,
              startingRadius: 1,
              currentRadius: 1,
              endRadius: 200,
              speed: 0.5
            },
            acceleration: 10,
            deceleration: 10,
            travelling: true,
            stopping: false,
            launchTime: 0,
            onApproach: false,
            distanceToDestination: distanceAndAngleBetweenTwoPoints(
              origin.x,
              origin.y,
              destination.x,
              destination.y
            ).distance
          };
        });
        return fleet;
      }

      //Aliases
      let Application = PIXI.Application,
        loader = PIXI.loader,
        resources = PIXI.loader.resources,
        Sprite = PIXI.Sprite,
        Graphics = PIXI.Graphics,
        Text = PIXI.Text;

      //Create a Pixi Application
      let app = new Application({
        width: 512,
        height: 512,
        antialias: true,
        transparent: false,
        resolution: 1
      });

      // let width = window.innerWidth;
      // let height = window.innerHeight;

      let width = 2000;
      let height = 2000;

      function generateUniverse(size, density) {
        const stars = Math.floor((size * size) / density);
        const starCoords = new Array(stars).fill(undefined).map(() => ({
          x: getRandomWholeNumber(10, size),
          y: getRandomWholeNumber(10, size)
        }));
        return starCoords;
      }

      // app.renderer.view.style.position = "absolute";
      // app.renderer.view.style.display = "block";
      app.renderer.autoResize = true;
      app.renderer.resize(width, height);
      // app.renderer.backgroundColor = 0x120114;
      app.renderer.backgroundColor = `linear-gradient(
            30deg,
            rgba(57, 160, 237, 0.075),
            rgba(255, 255, 255, 0.01)
          ),
          linear-gradient(
            100deg,
            rgba(100, 11, 40, 0.075),
            rgba(94, 252, 141, 0.075)
          );`;

      //Add the canvas that Pixi automatically created for you to the HTML document
      const canvasWrapper = document.getElementById("canvas__wrapper");
      canvasWrapper.appendChild(app.view);

      const canvasPos = {
        x: 0,
        y: 0
      };

      function keyboard(value) {
        let key = {};
        key.value = value;
        key.isDown = false;
        key.isUp = true;
        key.press = undefined;
        key.release = undefined;
        //The `downHandler`
        key.downHandler = event => {
          if (event.key === key.value) {
            if (key.isUp && key.press) key.press();
            key.isDown = true;
            key.isUp = false;
            event.preventDefault();
          }
        };

        //The `upHandler`
        key.upHandler = event => {
          if (event.key === key.value) {
            if (key.isDown && key.release) key.release();
            key.isDown = false;
            key.isUp = true;
            event.preventDefault();
          }
        };

        //Attach event listeners
        const downListener = key.downHandler.bind(key);
        const upListener = key.upHandler.bind(key);

        window.addEventListener("keydown", downListener, false);
        window.addEventListener("keyup", upListener, false);

        // Detach event listeners
        key.unsubscribe = () => {
          window.removeEventListener("keydown", downListener);
          window.removeEventListener("keyup", upListener);
        };

        return key;
      }

      let translate = false;
      let keyObject = keyboard("ArrowDown");

      keyObject.press = () => {
        //key object pressed'
        console.log("down");
        translate = true;
      };
      keyObject.release = () => {
        //key object released
        console.log("stop");
        translate = false;
      };

      //load an image and run the `setup` function when it's done
      loader
        .add([
          "assets/sprites/ship.png",
          "assets/sprites/ship-selected.png",
          "assets/sprites/ship-selection-ring.png"
        ])
        .load(setup);

      let spaceship;
      let spaceshipSelected;
      let selectionRing;
      let fleet;
      let superFastSprites = new PIXI.particles.ParticleContainer();
      let graphics;
      let universe;

      function getTravelData(ship, milliseconds) {
        const travelData = {};
        travelData.distanceAndAngle = distanceAndAngleBetweenTwoPoints(
          ship.coordinates.x,
          ship.coordinates.y,
          ship.destination.x,
          ship.destination.y
        );
        travelData.shipVector = new Vector(
          ship.velocity,
          travelData.distanceAndAngle.angle
        );
        travelData.elapsedSeconds = milliseconds / 1000;
        return travelData;
      }
      function go() {
        fleet.forEach(ship => {
          ship.travelling = !ship.travelling;
        });
      }
      let mouse;
      let selectedShip;

      function getStarRadius() {
        const starSizes = [0.35, 0.6, 0.85, 1];
        const random = Math.random();
        if (random <= 0.3) {
          return starSizes[0];
        }
        if (random > 0.3 && random <= 0.8) {
          return starSizes[1];
        }
        if (random > 0.8 && random <= 0.95) {
          return starSizes[2];
        }
        if (random > 0.95) {
          return starSizes[3];
        }
      }

      function centerView(coordinates) {
        const newX = (coordinates.x - window.innerWidth / 2) * -1;
        const newY = (coordinates.y - window.innerHeight / 2) * -1;

        const newMapPosition = {
          x:
            newX < 0 && newX > (2000 - window.innerWidth) * -1
              ? newX + 4
              : newX > 0
              ? 0
              : newX < (2000 - window.innerWidth) * -1
              ? (2000 - window.innerWidth) * -1
              : newX + 4,
          y:
            newY < 0 && newY > (2000 - window.innerHeight) * -1
              ? newY
              : newY > 0
              ? 0
              : newY < (2000 - window.innerHeight) * -1
              ? (2000 - window.innerHeight) * -1
              : newY
        };

        canvasPos.x = newMapPosition.x;
        canvasPos.y = newMapPosition.y;
        canvasWrapper.style.transform = `translate(${canvasPos.x}px,${
          canvasPos.y
        }px)`;
      }

      //This `setup` function will run when the image has loaded
      function setup() {
        app.view.addEventListener("mousemove", function(event) {
          const bounds = event.target.getBoundingClientRect();
          const newMouse = {
            x: event.x - bounds.left,
            y: event.y - bounds.top
          };
          mouse = newMouse;
        });
        app.view.addEventListener("click", function(event) {
          const bounds = event.target.getBoundingClientRect();
          const clickCoords = {
            x: event.x - bounds.left,
            y: event.y - bounds.top
          };
          const clickedShip = fleet.filter(ship => {
            return checkProximity(5, clickCoords, ship.coordinates);
          })[0];
          if (clickedShip) {
            selectedShip = clickedShip;
            centerView(clickedShip.coordinates);
          } else {
            selectedShip = undefined;
          }
        });

        fleet = generateFleet();
        fleet.forEach(ship => {
          // add textures
          ship.unselected = resources["assets/sprites/ship.png"].texture;
          ship.selected = resources["assets/sprites/ship-selected.png"].texture;

          // add sprites
          ship.selection = new Sprite(
            resources["assets/sprites/ship-selection-ring.png"].texture
          );
          ship.destinationSprite = new Sprite(
            resources["assets/sprites/ship-selected.png"].texture
          );

          ship.destinationSprite.height = 10;
          ship.destinationSprite.width = 10;

          // assign starting sprite and starting texture
          ship.sprite = new Sprite();
          ship.sprite.texture = ship.unselected;

          // add message
          ship.message = new Text(`SHIP`, style);

          app.stage.addChild(ship.sprite);
          app.stage.addChild(ship.selection);
          app.stage.addChild(ship.destinationSprite);
        });

        universe = generateUniverse(width, 500);
        universe.forEach(starCoordinate => {
          let circle = new Graphics();
          circle.beginFill(0xffffff);
          circle.drawCircle(
            starCoordinate.x,
            starCoordinate.y,
            getStarRadius()
          );
          circle.endFill();
          app.stage.addChild(circle);
        });

        //Set the game state
        state = play;

        //Start the game loop
        app.ticker.add(delta => gameLoop(delta));
      }

      function gameLoop(delta) {
        //Update the current game state:
        state(delta);
      }

      let style = new PIXI.TextStyle({
        fontFamily: "Arial",
        fontSize: 20,
        fill: "white"
      });

      function checkProximity(distance, origin, target) {
        if (
          origin.x - target.x < distance &&
          origin.x - target.x > distance * -1 &&
          origin.y - target.y < distance &&
          origin.y - target.y > distance * -1
        ) {
          return true;
        }
        return false;
      }

      function play(delta) {
        stats.begin();
        if (translate) {
          console.log("move it");
          canvasPos.y -= 1;
          canvasWrapper.style.transform = `translate(${canvasPos.x}px,${
            canvasPos.y
          }px)`;
        }
        fleet.forEach((ship, index) => {
          if (ship.travelling) {
            const travelData = getTravelData(ship, delta);
            const distanceToDestination = travelData.distanceAndAngle.distance;
            ship.distanceToDestination = distanceToDestination;
            if (ship.distanceToDestination < 10) {
              ship.origin = ship.coordinates;
              ship.destination = {
                x: getRandomWholeNumber(0, width),
                y: getRandomWholeNumber(0, height)
              };
            }
            const newShipX =
              ship.coordinates.x +
              travelData.shipVector.magnitudeX * travelData.elapsedSeconds;
            const newShipY =
              ship.coordinates.y +
              travelData.shipVector.magnitudeY * travelData.elapsedSeconds;

            ship.coordinates = { x: newShipX, y: newShipY };

            if (mouse && checkProximity(5, ship.coordinates, mouse)) {
              ship.sprite.height = 20;
              ship.sprite.width = 20;
              ship.sprite.x = newShipX - 10;
              ship.sprite.y = newShipY - 10;
            } else {
              ship.sprite.height = 6;
              ship.sprite.width = 6;
              ship.sprite.x = newShipX - 3;
              ship.sprite.y = newShipY - 3;
            }

            if (selectedShip && ship.name === selectedShip.name) {
              centerView(ship.coordinates);
              // TODO: only do this the first time
              // change sprite texture
              ship.sprite.texture = ship.selected;
              // change sprite size
              ship.sprite.height = 10;
              ship.sprite.width = 10;
              // make the selection ring visible
              ship.selection.visible = true;
              ship.destinationSprite.visible = true;
              // TODO: only do this the first time

              // change sprite position
              ship.sprite.x = newShipX - 5;
              ship.sprite.y = newShipY - 5;
              ship.selection.x = newShipX - 20;
              ship.selection.y = newShipY - 20;
              ship.destinationSprite.x = ship.destination.x - 5;
              ship.destinationSprite.y = ship.destination.y - 5;

              // draw ship destination line and text

              // remove previous line and text
              app.stage.removeChild(ship.line);
              app.stage.removeChild(ship.message);

              // update ship message position and add to stage
              ship.message.position.set(ship.coordinates.x, ship.coordinates.y);
              app.stage.addChild(ship.message);

              // add line primitive and add to stage
              ship.line = new Graphics();
              ship.line.lineStyle(2, 0xffffff, 1);
              ship.line.moveTo(newShipX, newShipY);
              ship.line.lineTo(ship.destination.x, ship.destination.y);
              app.stage.addChild(ship.line);
            } else {
              // TODO: only do this the first time
              app.stage.removeChild(ship.line);
              app.stage.removeChild(ship.message);
              ship.sprite.texture = ship.unselected;
              ship.selection.visible = false;
              ship.destinationSprite.visible = false;
              // TODO: only do this the first time
            }
          }
        });
        stats.end();
      }
    </script>
  </body>
</html>
