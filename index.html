<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./mapPanStyles.css" />
    <title>Fleet Commander</title>
    <style>
      @font-face {
        font-family: "lovecraft";
        src: local("lovecraft"),
          url("./assets/fonts/lovecraft.ttf") format("truetype");
      }
      @font-face {
        font-family: "Inconsolata";
        src: url("./assets/fonts/Inconsolata-Regular.ttf") format("truetype");
      }
      @font-face {
        font-family: "Inconsolata";
        src: url("./assets/fonts/Inconsolata-Regular.ttf") format("truetype");
        font-weight: bold;
      }
      * {
        box-sizing: border-box;
        font-family: "Inconsolata", monospace;
        letter-spacing: 2px;
        margin: 0;
        padding: 0;
        -webkit-user-select: none; /* Safari 3.1+ */
        -moz-user-select: none; /* Firefox 2+ */
        -ms-user-select: none; /* IE 10+ */
        user-select: none; /* Standard syntax */
      }
      body {
        align-items: center;
        background: #120114;
        display: flex;
        height: 100vh;
        justify-content: center;
        overflow: hidden;
        width: 100vw;
      }
      body::after {
        background: repeating-linear-gradient(
          0deg,
          rgba(255, 255, 255, 0.05),
          rgba(112, 255, 233, 0.05) 5px,
          transparent 1px,
          transparent 2px
        );
        content: "";
        height: 100vh;
        left: 0;
        pointer-events: none;
        position: absolute;
        top: 0;
        width: 100vw;
        z-index: 100;
      }
      .bordered {
        border-radius: 1px;
        border: 4px solid rgba(112, 255, 255, 0.9);
        box-shadow: inset 0 0 10px rgba(112, 255, 255, 0.5),
          0 0 10px rgba(112, 255, 255, 0.5);
      }
      .bordered--white {
        border-radius: 1px;
        border: 4px solid rgba(255, 255, 255, 0.9);
        box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.5),
          0 0 10px rgba(255, 255, 255, 0.5);
      }
      .blue__glow {
        color: rgba(112, 255, 255, 0.9);
        text-shadow: 0px 0px 6px rgba(112, 255, 255, 0.8);
      }
      .white__glow {
        color: #fff;
        text-shadow: 0px 0px 6px rgba(255, 255, 255, 0.8);
      }
      .padded {
        padding: 15px;
      }
      .padded--light {
        padding: 5px;
      }
      .padded--lighter {
        padding: 2px 5px;
      }
      .grid {
        display: grid;
        grid-gap: 15px;
      }
      .grid--nogap {
        grid-gap: 0px;
      }
      .grid--c {
        grid-auto-flow: column;
        justify-content: start;
      }
      .grid--r {
        grid-auto-flow: row;
        align-content: start;
      }
      .grid--r--split {
        align-content: space-between;
      }
      .grid--c--split {
        justify-content: space-between;
      }
      .interface {
        /* display: grid; */
        grid-template-areas:
          "header   menu"
          "game     menu"
          "controls menu";
        grid-template-columns: minmax(auto, 2000px) minmax(325px, auto);
        grid-template-rows: auto minmax(auto, 2000px) auto;
        height: calc(100% - 50px);
        width: calc(100% - 50px);
      }
      .canvas__wrapper {
        position: absolute;
        background-image: linear-gradient(
            30deg,
            rgba(57, 160, 237, 0.075),
            rgba(255, 255, 255, 0.01)
          ),
          linear-gradient(
            100deg,
            rgba(100, 11, 40, 0.075),
            rgba(94, 252, 141, 0.075)
          );
        z-index: 5;
      }
      .game {
        grid-area: game;
        height: 100%;
        overflow: hidden;
        position: relative;
        box-shadow: inset 0px 0px 200px rgba(0, 0, 0, 1);
      }
      .game__controls {
        grid-area: controls;
        width: 100%;
      }
      .header {
        grid-area: header;
      }
      .menu {
        grid-area: menu;
        overflow: hidden;
        overflow-y: scroll;
        width: 100%;
      }
      .menu__content {
        height: 100%;
      }

      .menu__controls {
        margin-top: 50px;
      }

      .info__item {
        font-size: 30px;
      }

      .info__label {
        padding-left: 8px;
      }

      .menu > .control {
        width: 100%;
      }

      .control {
        background: none;
        outline: none;
        cursor: pointer;
        font-size: 30px;
        transition: all 500ms ease-out;
      }
      .control:active {
        color: #fff;
        border: 4px solid rgba(255, 255, 255, 1);
        box-shadow: inset 0 0 10px rgba(255, 255, 255, 1),
          0 0 10px rgba(255, 255, 255, 1);
        text-shadow: 0px 0px 6px rgba(255, 255, 255, 1);
        transition: none;
      }
      .control--inactive {
        opacity: 0.5;
        pointer-events: none;
        cursor: default;
      }
      .line {
        background: red;
        position: absolute;
        z-index: 100;
        /* outline: 1px dashed red; */
      }
      .line--v {
        height: 100%;
        left: 50%;
        width: 1px;
      }
      .line--h {
        height: 1px;
        width: 100%;
        top: 50%;
      }
      .dev__data {
        color: rgba(112, 255, 255, 0.9);
        font-size: 10px;
        left: 25px;
        position: fixed;
        top: 7px;
        text-shadow: 0px 0px 6px rgba(112, 255, 255, 0.5);
      }
    </style>
  </head>
  <script src="stats/stats.min.js"></script>
  <script src="pixi/pixi.min.js"></script>
  <body>
    <div class="interface bordered padded grid">
      <div class="dev__data grid grid--c">
        <span>BUILD development</span>
        <span id="fps">LOADING</span>
        <span id="shipCount"></span>
        <span id="starCount"></span>
      </div>
      <div class="header bordered padded grid grid--c">
        <button
          id="dev_console"
          class="control bordered padded--lighter blue__glow"
        >
          DVP
        </button>
        <button class="control bordered padded--lighter blue__glow">
          LST
        </button>
        <button class="control bordered padded--lighter blue__glow">
          LNCH
        </button>
        <button
          class="control control--inactive bordered padded--lighter blue__glow"
        >
          SCN
        </button>
      </div>
      <div id="game__container" class="game bordered">
        <!-- <div class="line line--v"></div>
        <div class="line line--h"></div> -->
        <div class="map__pan__control map__pan__control--topLeft"></div>
        <div class="map__pan__control map__pan__control--top"></div>
        <div class="map__pan__control map__pan__control--topRight"></div>
        <div class="map__pan__control map__pan__control--right"></div>
        <div class="map__pan__control map__pan__control--bottomRight"></div>
        <div class="map__pan__control map__pan__control--bottom"></div>
        <div class="map__pan__control map__pan__control--bottomLeft"></div>
        <div class="map__pan__control map__pan__control--left"></div>
        <div id="canvas__wrapper" class="canvas__wrapper"></div>
      </div>
      <div class="game__controls bordered padded grid grid--c grid--c--split">
        <div>
          <button class="control bordered padded--lighter blue__glow">
            SHP
          </button>
          <button class="control bordered padded--lighter blue__glow">
            DSTN
          </button>
        </div>
        <div>
          <button class="control bordered padded--lighter blue__glow">
            LCK
          </button>
          <button class="control bordered padded--lighter blue__glow">
            DSL
          </button>
        </div>
      </div>
      <div class="menu bordered padded ">
        <div class="menu__content grid grid--r grid--r--split">
          <div class="menu__data grid grid--r">
            <div class="info__item grid grid--nogap grid-r">
              <span class="info__label blue__glow padded--light">LBL</span>
              <span class="info__value bordered padded--light white__glow"
                >VL</span
              >
            </div>
          </div>
          <div class="menu__controls grid grid-r">
            <button class="control bordered padded--lighter blue__glow">
              STP
            </button>
            <button class="control bordered padded--lighter blue__glow">
              SCN
            </button>
          </div>
        </div>
      </div>
    </div>
    <script type="text/javascript">
      // STATS
      const stats = new Stats();
      document.body.appendChild(stats.dom);
      stats.showPanel(0, 1, 2); // 0: fps, 1: ms, 2: mb, 3+: custom
      // STATS

      // VARIABLES
      let mouse;
      let selectedShip;
      let fleet;
      let universe;
      let translate = false;

      const fleetSize = 1000;
      const shipVelocity = 1000;
      const gamesize = 3000; // universe size
      const starDensity = 90;
      const generateShips = false;

      const canvasPos = {
        x: 0,
        y: 0
      };
      // VARIABLES

      // DOM
      const canvasWrapper = document.getElementById("canvas__wrapper");
      const fpsCounter = document.getElementById("fps");
      const shipCount = document.getElementById("shipCount");
      const starCount = document.getElementById("starCount");
      const gameContainer = document.getElementById("game__container");
      const devButton = document.getElementById("dev_console");
      const gameContainerSize = {
        height: gameContainer.clientHeight,
        width: gameContainer.clientWidth
      };
      // DOM

      // INIT PIXI
      let Application = PIXI.Application,
        loader = PIXI.Loader.shared,
        resources = PIXI.Loader.shared.resources,
        Sprite = PIXI.Sprite,
        Graphics = PIXI.Graphics,
        Text = PIXI.Text;
      let starContainer;
      let shipContainer;
      let style = new PIXI.TextStyle({
        fontFamily: "Inconsolata",
        letterSpacing: 1.5,
        fontSize: 12,
        fontWeight: 700,
        fill: "white"
      });
      let type = "WebGL";
      if (!PIXI.utils.isWebGLSupported()) {
        type = "canvas";
      }
      // PIXI.utils.sayHello(type);
      PIXI.utils.skipHello(type);
      let app = new Application({
        width: gamesize,
        height: gamesize,
        antialias: true,
        transparent: true,
        resolution: 1
      });
      canvasWrapper.appendChild(app.view);
      // load assets
      loader
        .add([
          "assets/sprites/ship.png",
          "assets/sprites/ship-selected.png",
          "assets/sprites/ship-selection-ring.png",
          "assets/sprites/star.png"
        ])
        .load(setup);
      // INIT PIXI

      // TEXTURES
      let unselectShipTexture;
      let selectedShipTexture;
      let selectionRingTexture;
      let starTexture;
      // TEXTURES

      // FUNCTIONS
      function getRandomWholeNumber(min, max) {
        return Math.floor(Math.random() * max) + min;
      }

      function distanceAndAngleBetweenTwoPoints(x1, y1, x2, y2) {
        const x = x2 - x1;
        const y = y2 - y1;

        return {
          distance: Math.sqrt(x * x + y * y),
          angle: (Math.atan2(y, x) * 180) / Math.PI
        };
      }

      function Vector(magnitude, angle) {
        var angleRadians = (angle * Math.PI) / 180;

        this.magnitudeX = magnitude * Math.cos(angleRadians);
        this.magnitudeY = magnitude * Math.sin(angleRadians);
      }

      function getRandomStar() {
        return universe[getRandomWholeNumber(0, universe.length - 1)];
      }

      function makeShip(index) {
        const origin = getRandomStar();
        let destination = getRandomStar();
        return {
          name: `SHIP-${index + 1}`,
          origin,
          destination,
          direction: origin.x > destination.x ? "west" : "east",
          directionY: origin.y > destination.y ? "north" : "south",
          coordinates: origin,
          // id: uuid(),
          status: "STD",
          velocity: shipVelocity,
          radius: {
            base: 3,
            hover: 10,
            selected: 6
          },
          maxVelocity: 10,
          prepTime: 10,
          setSelected: false,
          scanning: {
            active: false,
            startingRadius: 1,
            currentRadius: 1,
            endRadius: 200,
            speed: 0.5
          },
          acceleration: 10,
          deceleration: 10,
          travelling: true,
          stopping: false,
          launchTime: 0,
          onApproach: false,
          distanceToDestination: distanceAndAngleBetweenTwoPoints(
            origin.x,
            origin.y,
            destination.x,
            destination.y
          ).distance
        };
      }

      function generateFleet() {
        const fleet = new Array(fleetSize)
          .fill(undefined)
          .map((value, index) => {
            return makeShip(index);
          });
        return fleet;
      }

      function generateUniverse(size, density) {
        const stars = Math.floor((size * size) / density);
        const starCoords = new Array(stars).fill(undefined).map(() => ({
          x: getRandomWholeNumber(10, size),
          y: getRandomWholeNumber(10, size)
        }));
        return starCoords;
      }

      function getTravelData(ship, milliseconds) {
        const travelData = {};
        travelData.distanceAndAngle = distanceAndAngleBetweenTwoPoints(
          ship.coordinates.x,
          ship.coordinates.y,
          ship.destination.x,
          ship.destination.y
        );
        travelData.shipVector = new Vector(
          ship.velocity,
          travelData.distanceAndAngle.angle
        );
        travelData.elapsedSeconds = milliseconds / 1000;
        return travelData;
      }

      function getStarRadius() {
        const starSizes = [0.5, 1, 2, 3];
        const random = Math.random();
        if (random <= 0.3) {
          return starSizes[0];
        }
        if (random > 0.3 && random <= 0.8) {
          return starSizes[1];
        }
        if (random > 0.8 && random <= 0.95) {
          return starSizes[2];
        }
        if (random > 0.95) {
          return starSizes[3];
        }
      }

      function centerView(coordinates) {
        const newX = (coordinates.x - (gameContainerSize.width + 1) / 2) * -1;
        const newY = (coordinates.y - (gameContainerSize.height + 2) / 2) * -1;

        const newMapPosition = {
          x:
            newX < 0 && newX > (gamesize - gameContainerSize.width) * -1
              ? newX
              : newX >= 0
              ? 0
              : newX < (gamesize - gameContainerSize.width) * -1
              ? (gamesize - gameContainerSize.width) * -1
              : newX,
          y:
            newY < 0 && newY > (gamesize - (gameContainerSize.height - 4)) * -1
              ? newY
              : newY >= 0
              ? 0
              : newY < (gamesize - (gameContainerSize.height - 4)) * -1
              ? (gamesize - (gameContainerSize.height - 4)) * -1
              : newY
        };

        canvasPos.x = newMapPosition.x;
        canvasPos.y = newMapPosition.y;
        canvasWrapper.style.transform = `translate(${canvasPos.x}px,${
          canvasPos.y
        }px)`;
      }

      function initShipSprites(ship) {
        ship.sprite = new Sprite();
        ship.sprite.texture = unselectShipTexture;

        // add message
        ship.message = new Text(ship.name, style);
        ship.message.resolution = 2;
        ship.message.visible = false;

        app.stage.addChild(ship.sprite);
        app.stage.addChild(ship.message);
        app.stage.addChild(ship.selection);
        app.stage.addChild(ship.destinationSprite);
      }

      let destinationSprite;
      let selectionSprite;
      let hoverSprite;
      //This `setup` function will run when the image has loaded
      function setup() {
        // TEXTURES
        unselectShipTexture = resources["assets/sprites/ship.png"].texture;
        selectedShipTexture =
          resources["assets/sprites/ship-selected.png"].texture;
        selectionRingTexture =
          resources["assets/sprites/ship-selection-ring.png"].texture;
        starTexture = resources["assets/sprites/star.png"].texture;
        // TEXTURES
        function updateMouse(event) {
          const bounds = event.target.getBoundingClientRect();
          const newMouse = {
            x: event.x - bounds.left,
            y: event.y - bounds.top
          };
          mouse = newMouse;
        }
        app.view.addEventListener("mousemove", function(event) {
          updateMouse(event);
        });
        app.view.addEventListener("click", function(event) {
          const bounds = event.target.getBoundingClientRect();
          const clickCoords = {
            x: event.x - bounds.left,
            y: event.y - bounds.top
          };
          const clickedShip = fleet.filter(ship => {
            return checkProximity(5, clickCoords, ship.coordinates);
          })[0];
          if (clickedShip) {
            selectedShip = clickedShip;
            centerView(clickedShip.coordinates);
          } else {
            selectedShip = undefined;
          }
        });

        universe = generateUniverse(gamesize, starDensity);
        starCount.innerText = `STARS ${universe.length.toLocaleString()}`;
        starContainer = new PIXI.ParticleContainer();
        universe.forEach(starCoordinate => {
          const star = new Sprite(starTexture);
          const starSize = getStarRadius();
          star.x = starCoordinate.x;
          star.y = starCoordinate.y;
          star.height = starSize;
          star.width = starSize;
          star.resolution = 1;
          starContainer.addChild(star);
        });
        app.stage.addChild(starContainer);

        fleet = generateFleet();
        shipContainer = new PIXI.ParticleContainer();
        fleet.forEach(ship => {
          // assign starting sprite and starting texture
          ship.sprite = new Sprite();
          ship.sprite.texture = unselectShipTexture;
          ship.sprite.height = 6;
          ship.sprite.width = 6;

          // add message
          ship.message = new Text(ship.name, style);
          ship.message.resolution = 2;
          ship.message.visible = false;

          shipContainer.addChild(ship.sprite);
        });
        app.stage.addChild(shipContainer);

        destinationSprite = new Sprite(selectedShipTexture);
        selectionSprite = new Sprite(selectionRingTexture);
        hoverSprite = new Sprite(selectedShipTexture);
        selectedShipSprite = new Sprite(selectedShipTexture);
        destinationSprite.height = 6;
        destinationSprite.width = 6;
        hoverSprite.height = 20;
        hoverSprite.width = 20;
        selectedShipSprite.height = 10;
        selectedShipSprite.width = 10;
        selectionSprite.visible = false;
        destinationSprite.visible = false;
        hoverSprite.visible = false;
        selectedShipSprite.visible = false;
        app.stage.addChild(selectionSprite);
        app.stage.addChild(destinationSprite);
        app.stage.addChild(hoverSprite);
        app.stage.addChild(selectedShipSprite);

        //Set the game state
        state = play;

        //Start the game loop
        app.ticker.add(delta => gameLoop(delta));
      }

      function gameLoop(delta) {
        //Update the current game state:
        state(delta);
      }

      function checkProximity(distance, origin, target) {
        if (
          origin.x - target.x < distance &&
          origin.x - target.x > distance * -1 &&
          origin.y - target.y < distance &&
          origin.y - target.y > distance * -1
        ) {
          return true;
        }
        return false;
      }

      let frames = 60;
      function play(delta) {
        stats.begin();
        frames++;
        if (frames >= 60) {
          frames = 0;
          const fps = app.ticker.FPS;
          fpsCounter.innerText = `FPS ${fps.toFixed(0)}`;
          shipCount.innerText = `SHIPS ${fleet.length}`;
          if (fps > 30 && generateShips) {
            const newShip = makeShip(fleet.length);
            initShipSprites(newShip);
            fleet.push(newShip);
          }
        }
        // update all ships
        let proxShip;
        fleet.forEach((ship, index) => {
          if (ship.travelling) {
            const travelData = getTravelData(ship, delta);
            const distanceToDestination = travelData.distanceAndAngle.distance;
            ship.distanceToDestination = distanceToDestination;
            if (ship.distanceToDestination < 1) {
              ship.origin = ship.coordinates;
              ship.destination = getRandomStar();
            }
            const newShipX =
              ship.coordinates.x +
              travelData.shipVector.magnitudeX * travelData.elapsedSeconds;
            const newShipY =
              ship.coordinates.y +
              travelData.shipVector.magnitudeY * travelData.elapsedSeconds;

            ship.coordinates = { x: newShipX, y: newShipY };

            if (mouse && checkProximity(5, ship.coordinates, mouse)) {
              proxShip = ship;
            }

            ship.sprite.x = newShipX - 3;
            ship.sprite.y = newShipY - 3;

            if (!selectedShip) {
              selectedShip = fleet[0];
            }
            if (selectedShip && ship.name === selectedShip.name) {
              // lock ship to view on each frame
              centerView(ship.coordinates);
              if (!ship.setSelected) {
                ship.setSelected = true;
                app.stage.addChild(ship.message);
                ship.message.visible = true;
              }
              // remove previous line and text
              app.stage.removeChild(ship.line);

              // update ship message position and add to stage
              ship.message.position.set(
                ship.coordinates.x + 25,
                ship.coordinates.y - 4.5
              );

              // add line primitive and add to stage
              ship.line = new Graphics();
              ship.line.lineStyle(1, 0x70ffe9);
              ship.line.moveTo(newShipX, newShipY);
              ship.line.lineTo(ship.destination.x, ship.destination.y);
              app.stage.addChild(ship.line);
            } else {
              if (ship.setSelected) {
                ship.setSelected = false;
                app.stage.removeChild(ship.line);
                app.stage.removeChild(ship.message);
              }
            }
          }
        });
        // update selection related sprites
        if (proxShip) {
          if (!hoverSprite.visible) {
            hoverSprite.visible = true;
          }
          if (canvasWrapper.style.cursor !== "pointer") {
            canvasWrapper.style.cursor = "pointer";
          }
          hoverSprite.x = proxShip.coordinates.x - 10;
          hoverSprite.y = proxShip.coordinates.y - 10;
        } else {
          if (hoverSprite.visible) {
            hoverSprite.visible = false;
          }
          if (canvasWrapper.style.cursor !== "default") {
            canvasWrapper.style.cursor = "default";
          }
        }
        if (selectedShip) {
          if (!selectedShipSprite.visible) {
            selectedShipSprite.visible = true;
          }
          selectionSprite.x = selectedShip.coordinates.x - 20;
          selectionSprite.y = selectedShip.coordinates.y - 20;
          selectionSprite.visible = true;
          destinationSprite.visible = true;
          destinationSprite.x = selectedShip.destination.x - 3;
          destinationSprite.y = selectedShip.destination.y - 3;
          selectedShipSprite.x = selectedShip.coordinates.x - 5;
          selectedShipSprite.y = selectedShip.coordinates.y - 5;
        } else {
          if (selectedShipSprite.visible) {
            selectedShipSprite.visible = false;
          }
        }
        stats.end();
      }

      // CONTROLS
      function keyboard(value) {
        let key = {};
        key.value = value;
        key.isDown = false;
        key.isUp = true;
        key.press = undefined;
        key.release = undefined;
        //The `downHandler`
        key.downHandler = event => {
          if (event.key === key.value) {
            if (key.isUp && key.press) key.press();
            key.isDown = true;
            key.isUp = false;
            event.preventDefault();
          }
        };

        //The `upHandler`
        key.upHandler = event => {
          if (event.key === key.value) {
            if (key.isDown && key.release) key.release();
            key.isDown = false;
            key.isUp = true;
            event.preventDefault();
          }
        };

        //Attach event listeners
        const downListener = key.downHandler.bind(key);
        const upListener = key.upHandler.bind(key);

        window.addEventListener("keydown", downListener, false);
        window.addEventListener("keyup", upListener, false);

        // Detach event listeners
        key.unsubscribe = () => {
          window.removeEventListener("keydown", downListener);
          window.removeEventListener("keyup", upListener);
        };

        return key;
      }

      let keyObject = keyboard("ArrowDown");
      keyObject.press = () => {
        translate = true;
      };
      keyObject.release = () => {
        translate = false;
      };
      // CONTROLS
    </script>
  </body>
</html>
